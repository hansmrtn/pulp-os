fn main() {
    linker_be_nice();
    println!("cargo:rustc-link-arg=-Tlinkall.x");
    generate_bitmap_fonts();
}

fn linker_be_nice() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() > 1 {
        let kind = &args[1];
        let what = &args[2];

        match kind.as_str() {
            "undefined-symbol" => match what.as_str() {
                what if what.starts_with("_defmt_") => {
                    eprintln!();
                    eprintln!(
                        "ðŸ’¡ `defmt` not found - make sure `defmt.x` is added as a linker script and you have included `use defmt_rtt as _;`"
                    );
                    eprintln!();
                }
                "_stack_start" => {
                    eprintln!();
                    eprintln!("ðŸ’¡ Is the linker script `linkall.x` missing?");
                    eprintln!();
                }
                what if what.starts_with("esp_rtos_") => {
                    eprintln!();
                    eprintln!(
                        "ðŸ’¡ `esp-radio` has no scheduler enabled. Make sure you have initialized `esp-rtos` or provided an external scheduler."
                    );
                    eprintln!();
                }
                "embedded_test_linker_file_not_added_to_rustflags" => {
                    eprintln!();
                    eprintln!(
                        "ðŸ’¡ `embedded-test` not found - make sure `embedded-test.x` is added as a linker script for tests"
                    );
                    eprintln!();
                }
                "free"
                | "malloc"
                | "calloc"
                | "get_free_internal_heap_size"
                | "malloc_internal"
                | "realloc_internal"
                | "calloc_internal"
                | "free_internal" => {
                    eprintln!();
                    eprintln!(
                        "ðŸ’¡ Did you forget the `esp-alloc` dependency or didn't enable the `compat` feature on it?"
                    );
                    eprintln!();
                }
                _ => (),
            },
            _ => {
                std::process::exit(1);
            }
        }

        std::process::exit(0);
    }

    println!(
        "cargo:rustc-link-arg=--error-handling-script={}",
        std::env::current_exe().unwrap().display()
    );
}

// Build-time font rasterisation.
// Scans assets/fonts/ for TTF files, classifies by weight/style, rasterises
// ASCII 0x20â€“0x7E to 1-bit bitmaps via fontdue, and emits font_data.rs.

use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

// Body sizes: 0 = Small, 1 = Medium, 2 = Large.
const BODY_PX_SMALL: f32 = 14.0;
const BODY_PX_MEDIUM: f32 = 21.0;
const BODY_PX_LARGE: f32 = 30.0;
// Heading sizes scale with the body index: Small=20, Medium=28, Large=40.
const HEADING_PX_SMALL: f32 = 20.0;
const HEADING_PX_MEDIUM: f32 = 28.0;
const HEADING_PX_LARGE: f32 = 40.0;

const BODY_SIZES: [(f32, &str); 3] = [
    (BODY_PX_SMALL, "SMALL"),
    (BODY_PX_MEDIUM, "MEDIUM"),
    (BODY_PX_LARGE, "LARGE"),
];

const HEADING_SIZES: [(f32, &str); 3] = [
    (HEADING_PX_SMALL, "SMALL"),
    (HEADING_PX_MEDIUM, "MEDIUM"),
    (HEADING_PX_LARGE, "LARGE"),
];

// Pixels with fontdue coverage >= this value become black.
const THRESHOLD: u8 = 100;

const FIRST_CHAR: u8 = 0x20;
const LAST_CHAR: u8 = 0x7E;
const GLYPH_COUNT: usize = (LAST_CHAR - FIRST_CHAR + 1) as usize;

fn generate_bitmap_fonts() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest = Path::new(&out_dir).join("font_data.rs");
    let mut out = fs::File::create(&dest).unwrap();

    let font_dir = Path::new("assets/fonts");

    // Discover TTF files and classify by style
    let regular = find_ttf(font_dir, &["Regular"]);
    let bold = find_ttf(font_dir, &["Bold"]);
    let italic = find_ttf(font_dir, &["Italic"]);

    // Re-run build if any TTF changes
    if let Some(ref p) = regular {
        println!("cargo:rerun-if-changed={}", p.display());
    }
    if let Some(ref p) = bold {
        println!("cargo:rerun-if-changed={}", p.display());
    }
    if let Some(ref p) = italic {
        println!("cargo:rerun-if-changed={}", p.display());
    }
    println!("cargo:rerun-if-changed=assets/fonts");

    // â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    writeln!(out, "// AUTO-GENERATED by build.rs â€” do not edit").unwrap();
    writeln!(out, "#[allow(clippy::all)]").unwrap();
    writeln!(
        out,
        "use crate::fonts::bitmap::{{BitmapFont, BitmapGlyph, GLYPH_COUNT}};"
    )
    .unwrap();
    writeln!(out).unwrap();

    let has_regular = regular.is_some();
    writeln!(out, "pub const HAS_REGULAR: bool = {};", has_regular).unwrap();
    for (_px, suffix) in &BODY_SIZES {
        writeln!(
            out,
            "pub const HAS_REGULAR_{suffix}: bool = {};",
            has_regular
        )
        .unwrap();
    }
    writeln!(out).unwrap();

    // â”€â”€ Regular â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if let Some(ref path) = regular {
        let data = fs::read(path).unwrap();
        let font = fontdue::Font::from_bytes(data.as_slice(), fontdue::FontSettings::default())
            .expect("failed to parse regular TTF");
        eprintln!(
            "cargo:warning=font: rasterising {} ({} glyphs) at {}/{}/{} px body, {}/{}/{} px heading",
            path.file_name().unwrap().to_string_lossy(),
            font.glyph_count(),
            BODY_PX_SMALL,
            BODY_PX_MEDIUM,
            BODY_PX_LARGE,
            HEADING_PX_SMALL,
            HEADING_PX_MEDIUM,
            HEADING_PX_LARGE,
        );
        for (px, suffix) in &BODY_SIZES {
            emit_font(&mut out, &font, &format!("REGULAR_BODY_{suffix}"), *px);
        }
        for (px, suffix) in &HEADING_SIZES {
            emit_font(&mut out, &font, &format!("REGULAR_HEADING_{suffix}"), *px);
        }
    } else {
        for (_px, suffix) in &BODY_SIZES {
            emit_stub(&mut out, &format!("REGULAR_BODY_{suffix}"));
        }
        for (_px, suffix) in &HEADING_SIZES {
            emit_stub(&mut out, &format!("REGULAR_HEADING_{suffix}"));
        }
    }

    // â”€â”€ Bold â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if let Some(ref path) = bold {
        let data = fs::read(path).unwrap();
        let font = fontdue::Font::from_bytes(data.as_slice(), fontdue::FontSettings::default())
            .expect("failed to parse bold TTF");
        eprintln!(
            "cargo:warning=font: rasterising {} at {}/{}/{} px body",
            path.file_name().unwrap().to_string_lossy(),
            BODY_PX_SMALL,
            BODY_PX_MEDIUM,
            BODY_PX_LARGE,
        );
        for (px, suffix) in &BODY_SIZES {
            emit_font(&mut out, &font, &format!("BOLD_BODY_{suffix}"), *px);
        }
    } else {
        for (_px, suffix) in &BODY_SIZES {
            emit_stub(&mut out, &format!("BOLD_BODY_{suffix}"));
        }
    }

    // â”€â”€ Italic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if let Some(ref path) = italic {
        let data = fs::read(path).unwrap();
        let font = fontdue::Font::from_bytes(data.as_slice(), fontdue::FontSettings::default())
            .expect("failed to parse italic TTF");
        eprintln!(
            "cargo:warning=font: rasterising {} at {}/{}/{} px body",
            path.file_name().unwrap().to_string_lossy(),
            BODY_PX_SMALL,
            BODY_PX_MEDIUM,
            BODY_PX_LARGE,
        );
        for (px, suffix) in &BODY_SIZES {
            emit_font(&mut out, &font, &format!("ITALIC_BODY_{suffix}"), *px);
        }
    } else {
        for (_px, suffix) in &BODY_SIZES {
            emit_stub(&mut out, &format!("ITALIC_BODY_{suffix}"));
        }
    }
}

/// Find the first .ttf file in `dir` whose name contains ALL of the
/// given `keywords` (case-insensitive).  Excludes files that match
/// "BoldItalic" unless that's specifically requested.
fn find_ttf(dir: &Path, keywords: &[&str]) -> Option<PathBuf> {
    let Ok(entries) = fs::read_dir(dir) else {
        return None;
    };
    let mut candidates: Vec<PathBuf> = entries
        .filter_map(|e| e.ok())
        .map(|e| e.path())
        .filter(|p| {
            p.extension()
                .map(|e| e.to_ascii_lowercase() == "ttf")
                .unwrap_or(false)
        })
        .collect();
    candidates.sort();

    for path in &candidates {
        let stem = path
            .file_stem()
            .unwrap_or_default()
            .to_string_lossy()
            .to_lowercase();

        // All keywords must be present
        let all_match = keywords.iter().all(|kw| stem.contains(&kw.to_lowercase()));
        if !all_match {
            continue;
        }

        // Reject BoldItalic when looking for just Bold or just Italic
        if keywords.len() == 1 {
            if keywords[0].eq_ignore_ascii_case("Bold") && stem.contains("italic") {
                continue;
            }
            if keywords[0].eq_ignore_ascii_case("Italic") && stem.contains("bold") {
                continue;
            }
        }

        return Some(path.clone());
    }
    None
}

/// Rasterise ASCII glyphs and emit static Rust tables for one
/// font + size combination.
fn emit_font(out: &mut fs::File, font: &fontdue::Font, name: &str, px: f32) {
    // Line metrics
    let lm = font
        .horizontal_line_metrics(px)
        .expect("font has no horizontal metrics");
    let line_height = lm.new_line_size.ceil() as u16;
    let ascent = lm.ascent.ceil() as u16;

    // Rasterise each glyph
    struct Glyph {
        advance: u8,
        offset_x: i8,
        offset_y: i8,
        width: u8,
        height: u8,
        bits: Vec<u8>,
    }

    let mut glyphs: Vec<Glyph> = Vec::with_capacity(GLYPH_COUNT);
    let mut total_bits: usize = 0;

    for code in FIRST_CHAR..=LAST_CHAR {
        let ch = code as char;
        let (metrics, coverage) = font.rasterize(ch, px);
        let w = metrics.width;
        let h = metrics.height;
        let row_bytes = (w + 7) / 8;

        // Pack coverage to 1-bit MSB-first
        let mut bits = Vec::with_capacity(row_bytes * h);
        for y in 0..h {
            for bx in 0..row_bytes {
                let mut byte = 0u8;
                for bit in 0..8usize {
                    let x = bx * 8 + bit;
                    if x < w && coverage[y * w + x] >= THRESHOLD {
                        byte |= 1 << (7 - bit);
                    }
                }
                bits.push(byte);
            }
        }

        // offset_y: from baseline to top row of bitmap (positive y is down).
        // fontdue ymin is the distance from the baseline to the bottom edge of
        // the bounding box (positive = above baseline), so the top row sits at
        // ymin + h above the baseline.  Negating gives the screen-space offset.
        let offset_y = -(metrics.ymin as i32) - (h as i32);

        total_bits += bits.len();
        glyphs.push(Glyph {
            advance: (metrics.advance_width + 0.5) as u8,
            offset_x: (metrics.xmin).clamp(-128, 127) as i8,
            offset_y: offset_y.clamp(-128, 127) as i8,
            width: w.min(255) as u8,
            height: h.min(255) as u8,
            bits,
        });
    }

    // â”€â”€ Emit glyph table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    writeln!(out, "static {name}_GLYPHS: [BitmapGlyph; GLYPH_COUNT] = [").unwrap();
    let mut offset: u16 = 0;
    for (i, g) in glyphs.iter().enumerate() {
        let ch = (FIRST_CHAR + i as u8) as char;
        writeln!(
            out,
            "    BitmapGlyph {{ advance: {:>2}, offset_x: {:>3}, offset_y: {:>4}, width: {:>2}, height: {:>2}, bitmap_offset: {:>5} }}, // {:?}",
            g.advance, g.offset_x, g.offset_y, g.width, g.height, offset, ch
        ).unwrap();
        offset += g.bits.len() as u16;
    }
    writeln!(out, "];").unwrap();
    writeln!(out).unwrap();

    // â”€â”€ Emit bitmap data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    writeln!(out, "static {name}_BITMAPS: [u8; {total_bits}] = [").unwrap();
    let mut col = 0;
    for g in &glyphs {
        for &b in &g.bits {
            if col == 0 {
                write!(out, "    ").unwrap();
            }
            write!(out, "0x{b:02X},").unwrap();
            col += 1;
            if col >= 16 {
                writeln!(out).unwrap();
                col = 0;
            }
        }
    }
    if col > 0 {
        writeln!(out).unwrap();
    }
    writeln!(out, "];").unwrap();
    writeln!(out).unwrap();

    // â”€â”€ Emit BitmapFont struct â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    writeln!(out, "pub static {name}: BitmapFont = BitmapFont {{").unwrap();
    writeln!(out, "    glyphs: &{name}_GLYPHS,").unwrap();
    writeln!(out, "    bitmaps: &{name}_BITMAPS,").unwrap();
    writeln!(out, "    line_height: {line_height},").unwrap();
    writeln!(out, "    ascent: {ascent},").unwrap();
    writeln!(out, "}};").unwrap();
    writeln!(out).unwrap();
}

/// Emit a stub `Option<&BitmapFont>` = None for a missing font.
fn emit_stub(out: &mut fs::File, name: &str) {
    writeln!(
        out,
        "pub static {name}: BitmapFont = BitmapFont {{ glyphs: &[BitmapGlyph {{ advance: 0, offset_x: 0, offset_y: 0, width: 0, height: 0, bitmap_offset: 0 }}; GLYPH_COUNT], bitmaps: &[], line_height: 13, ascent: 13 }};"
    )
    .unwrap();
    writeln!(out).unwrap();
}
